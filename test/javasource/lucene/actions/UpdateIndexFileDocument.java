// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package lucene.actions;

import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.io.StringWriter;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.commons.io.IOUtils;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.TextField;
import org.apache.pdfbox.exceptions.CryptographyException;
import org.apache.pdfbox.exceptions.InvalidPasswordException;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.util.PDFTextStripper;
import org.apache.poi.POITextExtractor;
import org.apache.poi.extractor.ExtractorFactory;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.openxml4j.exceptions.OpenXML4JException;
import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.xssf.extractor.XSSFExcelExtractor;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xwpf.extractor.XWPFWordExtractor;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.tika.config.TikaConfig;
import org.apache.tika.detect.Detector;
import org.apache.tika.exception.TikaException;
import org.apache.tika.io.TikaInputStream;
import org.apache.tika.metadata.Metadata;
import org.apache.tika.mime.MediaType;
import org.apache.xmlbeans.XmlException;
import org.jsoup.Jsoup;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import lucene.helpers.LuceneFactory;
import system.proxies.FileDocument;
import com.mendix.systemwideinterfaces.core.IMendixObject;

/**
 * Index a filedocument. Supported formats: PDF, Word 97 (doc), Word 2007 (docx), Excel 97 (xls), Excel 2007 (xlsx), XML, Text
 */
public class UpdateIndexFileDocument extends CustomJavaAction<Boolean>
{
	private Long indexId;
	private IMendixObject __filedocument;
	private system.proxies.FileDocument filedocument;

	public UpdateIndexFileDocument(IContext context, Long indexId, IMendixObject filedocument)
	{
		super(context);
		this.indexId = indexId;
		this.__filedocument = filedocument;
	}

	@Override
	public Boolean executeAction() throws Exception
	{
		this.filedocument = __filedocument == null ? null : system.proxies.FileDocument.initialize(getContext(), __filedocument);

		// BEGIN USER CODE
		InputStream is = Core.getFileDocumentContent(getContext(), filedocument.getMendixObject());

		try {
			String text = null;
			MediaType mediaType = getFileFormat(filedocument);
			logger.debug("Index file document, filetype " + mediaType.toString());
			switch (mediaType.toString()){
			case "application/pdf": 
				text = textFromPDF(is);
				break;
			case "application/msword":
			case "application/vnd.ms-excel":
				text = textFromOffice97(is);
				break;
			case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
				text = textFromOfficeX(is);
				break;
			case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
				text = textFromXLSX(is);
				break;
			case "application/xml":
				text = textFromXML(is);
				break;
			case "text/html":
				text = textFromHTML(is);
				break;
			case "text/plain":
				text = textFromTextFile(is);
				break;
			default:
				logger.error("Unsupported file type " + mediaType.toString() + " " + filedocument.getName());
				break;
			}
			if (text != null) {
				// Add the tag-stripped contents as a Reader-valued Text field so it will
				// get tokenized and indexed.
				StringReader reader = new StringReader(text);
				Document doc = new Document();
				doc.add(new TextField(LuceneFactory.TEXT, reader));
				doc.add(new TextField(LuceneFactory.MXTYPE, __filedocument.getType(), Field.Store.YES));
				doc.add(new TextField(LuceneFactory.MXID, Long.toString(__filedocument.getId().toLong()), Field.Store.YES));
				LuceneFactory.getInstance().addDocumentQueued(indexId, doc);
			}
		} catch (Exception e){
			logger.error("Error indexing filedocument", e);
		}
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public String toString()
	{
		return "UpdateIndexFileDocument";
	}

	// BEGIN EXTRA CODE
	static ILogNode logger = Core.getLogger(LuceneFactory.NodeName);
	private static String textFromPDF(InputStream is) throws IOException{
		String contents = null;
		PDDocument pdfDocument = null;
		try{
			pdfDocument = PDDocument.load( is );

			if( pdfDocument.isEncrypted() ){
				//Try the default password and continu
				pdfDocument.decrypt( "" );
			} 
			//create a writer where to append the text.
			StringWriter strWriter = new StringWriter();
			PDFTextStripper stripper = new PDFTextStripper();
			stripper.writeText(pdfDocument, strWriter);
			contents = strWriter.getBuffer().toString(); 
		}
		catch( CryptographyException e ){
			throw new IOException  ( "Error decrypting document: " + e );
		}
		catch( InvalidPasswordException e )
		{
			//the default password "" was wrong.
			throw new IOException  ( "Error: The document is encrypted and will not be indexed." );
		}
		finally{
			if( pdfDocument != null ){
				pdfDocument.close();
			}
		}
		return contents;
	}
	private static String textFromOffice97(InputStream is) throws IOException, InvalidFormatException, OpenXML4JException, XmlException, SAXException, TikaException{
		POITextExtractor extractor;
		POIFSFileSystem fileSystem = new POIFSFileSystem(is);
		extractor = ExtractorFactory.createExtractor(fileSystem);
		return extractor.getText();
	}

	private static String textFromOfficeX(InputStream is) throws IOException, SAXException, TikaException{
		XWPFDocument document = new XWPFDocument(is);
		XWPFWordExtractor word = new XWPFWordExtractor(document);
		return word.getText();
	}

	/*
	 * Get all indexable text from an XLSX  
	 */
	private static String textFromXLSX(InputStream is) throws InvalidFormatException, IOException {
		OPCPackage pkg = OPCPackage.open(is);
		XSSFWorkbook wb = new XSSFWorkbook(pkg);
		XSSFExcelExtractor extractor = new  org.apache.poi.xssf.extractor.XSSFExcelExtractor(wb);

		extractor.setIncludeSheetNames(false);
		return extractor.getText();
	}
	/*
	 * Strip only the text contents of an XML file 
	 */

	private static String textFromXML(InputStream is) throws InvalidFormatException, IOException, ParserConfigurationException, SAXException {
		DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		org.w3c.dom.Document xdoc = dBuilder.parse(is);
		return extractTextChildren(xdoc.getDocumentElement());
	}
	/*
	 * recursive function to extract text nodes. Should be replaced with a streaming one.
	 */
	public static String extractTextChildren(Node parentNode) {
		NodeList childNodes = parentNode.getChildNodes();
		String result = new String();
		for (int i = 0; i < childNodes.getLength(); i++) {
			Node node = childNodes.item(i);
			if (node.getNodeType() == Node.TEXT_NODE) {
				if (node.getNodeValue() != null && !node.getNodeValue().trim().isEmpty()) {
					result += ' ' + node.getNodeValue().trim();
				}
			}
			result += extractTextChildren(node);
		}
		return result;
	}
	/*
	 * get the text from a text file 
	 */
	private static String textFromTextFile(InputStream  is) throws IOException {
		return org.apache.commons.io.IOUtils.toString(is);
	}
	/* 
	 * get text from html
	 */
	private static String textFromHTML(InputStream is) throws IOException {
		String htmlString = IOUtils.toString(is, "UTF-8");
		org.jsoup.nodes.Document doc = Jsoup.parse(htmlString );
		return doc.body().text(); 
	}
	/*
	 * Call apache tika to determine the file type
	 */

	public org.apache.tika.mime.MediaType getFileFormat(FileDocument fileDocument) throws IOException {
		org.apache.tika.mime.MediaType mediaType = null;
		InputStream is = Core.getFileDocumentContent(getContext(), fileDocument.getMendixObject());
		try {
			TikaConfig config = TikaConfig.getDefaultConfig();
			Detector detector = config.getDetector();

			TikaInputStream stream = TikaInputStream.get(is);
			try {
				Metadata metadata = new Metadata();
				metadata.add(Metadata.RESOURCE_NAME_KEY, fileDocument.getName());
				mediaType = detector.detect(stream, metadata);
			} finally {
				stream.close();
			}
		} finally {
			is.close();
		}
		return mediaType;
	}
	// END EXTRA CODE
}
